<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ã‚·ã‚§ãƒ«ãƒ”ãƒ³ã‚¹ã‚­ãƒ¼ã®ä¸‰è§’å½¢ - é«˜æ©Ÿèƒ½ç‰ˆ</title>
    <style>
        * {
            box-sizing: border-box;
        }
        body {
            font-family: 'Helvetica Neue', Arial, sans-serif;
            background-color: #f0f2f5;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            color: #333;
            min-height: 100vh;
            margin: 0;
        }

        h1 {
            margin-bottom: 10px;
            font-size: 24px;
        }

        .controls {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
            margin-bottom: 15px;
            justify-content: center;
        }

        .control-group {
            display: flex;
            gap: 8px;
            align-items: center;
            padding: 5px 10px;
            border: 1px solid #e0e0e0;
            border-radius: 5px;
            background: #fafafa;
        }

        input[type="number"] {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            width: 100px;
            text-align: right;
        }

        button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            transition: background 0.2s;
            color: white;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        button#btn-start { background-color: #28a745; }
        button#btn-start:hover:not(:disabled) { background-color: #218838; }

        button#btn-pause { background-color: #ffc107; color: #333; }
        button#btn-pause:hover:not(:disabled) { background-color: #e0a800; }

        button#btn-reset { background-color: #6c757d; }
        button#btn-reset:hover:not(:disabled) { background-color: #5a6268; }

        button#btn-add { background-color: #007bff; }
        button#btn-add:hover:not(:disabled) { background-color: #0056b3; }

        .canvas-container {
            width: 100%;
            max-width: 900px;
            height: 600px;
            border: 1px solid #ccc;
            background-color: white;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }

        canvas {
            display: block;
            cursor: grab;
        }
        canvas:active {
            cursor: grabbing;
        }

        .stats {
            margin-top: 10px;
            font-size: 14px;
            color: #666;
            text-align: center;
            width: 100%;
            max-width: 900px;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }

        .stat-item {
            padding: 10px;
            background: #f8f9fa;
            border-radius: 4px;
        }

        .stat-label {
            font-size: 12px;
            color: #888;
        }

        .stat-value {
            font-size: 18px;
            font-weight: bold;
            color: #333;
        }

        .help-text {
            font-size: 12px;
            color: #888;
            margin-top: 5px;
        }
    </style>
</head>
<body>

    <h1>ã‚·ã‚§ãƒ«ãƒ”ãƒ³ã‚¹ã‚­ãƒ¼ã®ä¸‰è§’å½¢ (ã‚«ã‚ªã‚¹ã‚²ãƒ¼ãƒ  - é«˜æ©Ÿèƒ½ç‰ˆ)</h1>

    <div class="controls">
        <div class="control-group">
            <button id="btn-start">â–¶ ã‚¹ã‚¿ãƒ¼ãƒˆ</button>
            <button id="btn-pause" disabled>â¸ ä¸€æ™‚åœæ­¢</button>
            <button id="btn-reset">âŸ³ ãƒªã‚»ãƒƒãƒˆ</button>
        </div>
        <div class="control-group">
            <label for="speed">æç”»é€Ÿåº¦:</label>
            <select id="speed">
                <option value="1">ã‚†ã£ãã‚Š (1ç‚¹/frame)</option>
                <option value="10">æ™®é€š (10ç‚¹/frame)</option>
                <option value="100" selected>é«˜é€Ÿ (100ç‚¹/frame)</option>
                <option value="500">è¶…é«˜é€Ÿ (500ç‚¹/frame)</option>
            </select>
        </div>
        <div class="control-group">
            <label for="iterations">è¿½åŠ ã™ã‚‹ç‚¹ã®æ•°:</label>
            <input type="number" id="iterations" value="10000" step="1000" min="1">
            <button id="btn-add">å®Ÿè¡Œ</button>
        </div>
    </div>

    <div class="canvas-container" id="canvas-container">
        <canvas id="myCanvas"></canvas>
    </div>
    
    <div class="stats">
        <p class="help-text">ğŸ–±ï¸ ãƒã‚¦ã‚¹ãƒ‰ãƒ©ãƒƒã‚°ã§ç§»å‹•ã€ãƒ›ã‚¤ãƒ¼ãƒ«ã§æ‹¡å¤§ç¸®å°ã§ãã¾ã™ï¼ˆGoogle Mapé¢¨æ“ä½œï¼‰</p>
        <div class="stats-grid">
            <div class="stat-item">
                <div class="stat-label">æ¼”ç®—å›æ•°ï¼ˆç·ç‚¹æ•°ï¼‰</div>
                <div class="stat-value" id="point-count">0</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">è¡¨ç¤ºä¸­ã®ç‚¹æ•°</div>
                <div class="stat-value" id="visible-count">0</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">ç¾åœ¨ã®æ‹¡å¤§ç‡</div>
                <div class="stat-value" id="zoom-level">1.00x</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹</div>
                <div class="stat-value" id="status">åœæ­¢ä¸­</div>
            </div>
        </div>
    </div>

    <script>
        // DOMè¦ç´ ã®å–å¾—
        const canvas = document.getElementById('myCanvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('canvas-container');
        const btnStart = document.getElementById('btn-start');
        const btnPause = document.getElementById('btn-pause');
        const btnReset = document.getElementById('btn-reset');
        const btnAdd = document.getElementById('btn-add');
        const speedSelect = document.getElementById('speed');
        const inputIterations = document.getElementById('iterations');
        const pointCountDisplay = document.getElementById('point-count');
        const visibleCountDisplay = document.getElementById('visible-count');
        const zoomLevelDisplay = document.getElementById('zoom-level');
        const statusDisplay = document.getElementById('status');

        // --- è¨­å®šå€¤ ---
        const WORLD_WIDTH = 600;
        const WORLD_HEIGHT = 520;
        const POINT_SIZE = 1.2;
        
        // è² è·è»½æ¸›ã®ãŸã‚ã®è¨­å®š
        const MAX_VISIBLE_POINTS = 100000; // æç”»ã™ã‚‹æœ€å¤§ç‚¹æ•°
        const CHUNK_SIZE = 10000; // ç‚¹ãƒ‡ãƒ¼ã‚¿ã‚’åˆ†å‰²ç®¡ç†ã™ã‚‹ãƒãƒ£ãƒ³ã‚¯ã‚µã‚¤ã‚º

        // ä¸‰è§’å½¢ã®é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ï¼ˆè«–ç†åº§æ¨™ï¼‰
        const vertices = [
            { x: WORLD_WIDTH / 2, y: 20 },
            { x: 20, y: WORLD_HEIGHT - 20 },
            { x: WORLD_WIDTH - 20, y: WORLD_HEIGHT - 20 }
        ];

        // --- çŠ¶æ…‹ç®¡ç†å¤‰æ•° ---
        // ãƒ¡ãƒ¢ãƒªåŠ¹ç‡åŒ–: ç‚¹ãƒ‡ãƒ¼ã‚¿ã‚’ãƒãƒ£ãƒ³ã‚¯åˆ†å‰²ã§ç®¡ç†
        let pointChunks = [];
        let currentChunk = [];
        let totalPoints = 0;
        let currentPoint = { x: WORLD_WIDTH / 2, y: WORLD_HEIGHT / 2 };

        // ãƒ“ãƒ¥ãƒ¼å¤‰æ›ç”¨å¤‰æ•°
        let scale = 1;
        let offsetX = 0;
        let offsetY = 0;

        // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åˆ¶å¾¡
        let isRunning = false;
        let animationId = null;

        // ãƒã‚¦ã‚¹æ“ä½œç”¨
        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;

        // --- ã‚­ãƒ£ãƒ³ãƒã‚¹åˆæœŸåŒ– ---
        function resizeCanvas() {
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            resetView();
            draw();
        }
        window.addEventListener('resize', resizeCanvas);

        function resetView() {
            scale = Math.min(canvas.width / WORLD_WIDTH, canvas.height / WORLD_HEIGHT) * 0.9;
            offsetX = (canvas.width - WORLD_WIDTH * scale) / 2;
            offsetY = (canvas.height - WORLD_HEIGHT * scale) / 2;
            updateZoomDisplay();
        }

        function updateZoomDisplay() {
            zoomLevelDisplay.textContent = scale.toFixed(2) + 'x';
        }

        function updateStatus(status) {
            statusDisplay.textContent = status;
        }

        // --- ã‚«ã‚ªã‚¹ã‚²ãƒ¼ãƒ ã®ãƒ­ã‚¸ãƒƒã‚¯ ---
        function calculatePoint() {
            const targetVertex = vertices[Math.floor(Math.random() * 3)];
            currentPoint.x = (currentPoint.x + targetVertex.x) / 2;
            currentPoint.y = (currentPoint.y + targetVertex.y) / 2;
            
            // ãƒãƒ£ãƒ³ã‚¯ç®¡ç†: ç¾åœ¨ã®ãƒãƒ£ãƒ³ã‚¯ãŒã„ã£ã±ã„ã«ãªã£ãŸã‚‰æ–°ã—ã„ãƒãƒ£ãƒ³ã‚¯ã‚’ä½œæˆ
            currentChunk.push({ x: currentPoint.x, y: currentPoint.y });
            if (currentChunk.length >= CHUNK_SIZE) {
                pointChunks.push(currentChunk);
                currentChunk = [];
            }
            totalPoints++;
        }

        function addPointsBatch(count) {
            for (let i = 0; i < count; i++) {
                calculatePoint();
            }
            pointCountDisplay.textContent = totalPoints.toLocaleString();
            draw();
        }

        // é€£ç¶šã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨ã®æ¼”ç®—
        function animationLoop() {
            if (!isRunning) return;

            const speed = parseInt(speedSelect.value);
            for (let i = 0; i < speed; i++) {
                calculatePoint();
            }
            pointCountDisplay.textContent = totalPoints.toLocaleString();
            draw();
            animationId = requestAnimationFrame(animationLoop);
        }

        // --- æç”»ï¼ˆè² è·è»½æ¸›æ©Ÿèƒ½ä»˜ãï¼‰---
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.translate(offsetX, offsetY);
            ctx.scale(scale, scale);

            // è¡¨ç¤ºç¯„å›²ã‚’è¨ˆç®—ï¼ˆç”»é¢å¤–ã®ç‚¹ã¯æç”»ã—ãªã„ï¼‰
            const viewLeft = -offsetX / scale;
            const viewTop = -offsetY / scale;
            const viewRight = (canvas.width - offsetX) / scale;
            const viewBottom = (canvas.height - offsetY) / scale;

            // é ‚ç‚¹ã‚’æç”»
            ctx.fillStyle = '#ff4444';
            vertices.forEach(v => {
                ctx.beginPath();
                ctx.arc(v.x, v.y, 5 / scale, 0, Math.PI * 2);
                ctx.fill();
            });

            // ç‚¹ã®æç”»ï¼ˆè² è·è»½æ¸›: è¡¨ç¤ºç¯„å›²å†…ã®ã¿ã€æœ€å¤§æ•°åˆ¶é™ï¼‰
            ctx.fillStyle = '#000000';
            ctx.beginPath();

            let visibleCount = 0;
            const drawSize = POINT_SIZE / scale;
            
            // è² è·è»½æ¸›ã®ãŸã‚ã®é–“å¼•ãç‡ã‚’è¨ˆç®—
            const skipRate = Math.max(1, Math.floor(totalPoints / MAX_VISIBLE_POINTS));

            // å…¨ãƒãƒ£ãƒ³ã‚¯ã‚’èµ°æŸ»
            let pointIndex = 0;
            for (let c = 0; c < pointChunks.length; c++) {
                const chunk = pointChunks[c];
                for (let i = 0; i < chunk.length; i++) {
                    // é–“å¼•ã: skipRateã”ã¨ã«1ç‚¹ã ã‘æç”»
                    if (pointIndex % skipRate === 0) {
                        const p = chunk[i];
                        // è¡¨ç¤ºç¯„å›²ãƒã‚§ãƒƒã‚¯ï¼ˆè¦–éŒå°ã‚«ãƒªãƒ³ã‚°ï¼‰
                        if (p.x >= viewLeft && p.x <= viewRight && p.y >= viewTop && p.y <= viewBottom) {
                            ctx.rect(p.x - drawSize/2, p.y - drawSize/2, drawSize, drawSize);
                            visibleCount++;
                        }
                    }
                    pointIndex++;
                }
            }
            
            // ç¾åœ¨ã®ãƒãƒ£ãƒ³ã‚¯ï¼ˆæœªç¢ºå®šåˆ†ï¼‰ã‚‚æç”»
            for (let i = 0; i < currentChunk.length; i++) {
                if (pointIndex % skipRate === 0) {
                    const p = currentChunk[i];
                    if (p.x >= viewLeft && p.x <= viewRight && p.y >= viewTop && p.y <= viewBottom) {
                        ctx.rect(p.x - drawSize/2, p.y - drawSize/2, drawSize, drawSize);
                        visibleCount++;
                    }
                }
                pointIndex++;
            }

            ctx.fill();
            ctx.restore();

            visibleCountDisplay.textContent = visibleCount.toLocaleString();
        }

        // --- ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ ---

        // ã‚¹ã‚¿ãƒ¼ãƒˆãƒœã‚¿ãƒ³
        btnStart.addEventListener('click', () => {
            if (isRunning) return;
            isRunning = true;
            btnStart.disabled = true;
            btnPause.disabled = false;
            updateStatus('æ¼”ç®—ä¸­...');
            animationLoop();
        });

        // ä¸€æ™‚åœæ­¢ãƒœã‚¿ãƒ³
        btnPause.addEventListener('click', () => {
            isRunning = false;
            btnStart.disabled = false;
            btnPause.disabled = true;
            updateStatus('ä¸€æ™‚åœæ­¢');
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
        });

        // ãƒªã‚»ãƒƒãƒˆãƒœã‚¿ãƒ³
        btnReset.addEventListener('click', () => {
            isRunning = false;
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            btnStart.disabled = false;
            btnPause.disabled = true;
            
            // ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¯ãƒªã‚¢
            pointChunks = [];
            currentChunk = [];
            totalPoints = 0;
            currentPoint = { x: Math.random() * WORLD_WIDTH, y: Math.random() * WORLD_HEIGHT };
            
            pointCountDisplay.textContent = '0';
            visibleCountDisplay.textContent = '0';
            updateStatus('åœæ­¢ä¸­');
            resetView();
            draw();
        });

        // æŒ‡å®šå›æ•°å®Ÿè¡Œãƒœã‚¿ãƒ³
        btnAdd.addEventListener('click', () => {
            const count = parseInt(inputIterations.value) || 0;
            if (count > 0) {
                updateStatus('æ¼”ç®—å®Ÿè¡Œä¸­...');
                // å¤§é‡ã®ç‚¹ã‚’è¿½åŠ ã™ã‚‹å ´åˆã¯éåŒæœŸã§å‡¦ç†
                if (count > 50000) {
                    let processed = 0;
                    const batchSize = 10000;
                    function processBatch() {
                        const remaining = count - processed;
                        const toProcess = Math.min(batchSize, remaining);
                        addPointsBatch(toProcess);
                        processed += toProcess;
                        if (processed < count) {
                            setTimeout(processBatch, 0);
                        } else {
                            updateStatus(isRunning ? 'æ¼”ç®—ä¸­...' : 'åœæ­¢ä¸­');
                        }
                    }
                    processBatch();
                } else {
                    addPointsBatch(count);
                    updateStatus(isRunning ? 'æ¼”ç®—ä¸­...' : 'åœæ­¢ä¸­');
                }
            }
        });

        // ãƒã‚¦ã‚¹ãƒ‰ãƒ©ãƒƒã‚°ã§ç§»å‹•ï¼ˆPanï¼‰
        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            const dx = e.clientX - lastMouseX;
            const dy = e.clientY - lastMouseY;
            offsetX += dx;
            offsetY += dy;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            draw();
        });

        window.addEventListener('mouseup', () => {
            isDragging = false;
        });

        // ãƒã‚¦ã‚¹ãƒ›ã‚¤ãƒ¼ãƒ«ã§æ‹¡å¤§ç¸®å°ï¼ˆZoomï¼‰
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();

            const scaleFactor = 1.1;
            const direction = e.deltaY < 0 ? 1 : -1;
            const newScale = scale * (direction > 0 ? scaleFactor : 1 / scaleFactor);
            
            // æ‹¡å¤§ç¸®å°ã®åˆ¶é™
            if (newScale < 0.1 || newScale > 500) return;

            // ãƒã‚¦ã‚¹ä½ç½®ã‚’ä¸­å¿ƒã«æ‹¡å¤§ç¸®å°
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            const worldX = (mouseX - offsetX) / scale;
            const worldY = (mouseY - offsetY) / scale;

            scale = newScale;

            offsetX = mouseX - worldX * scale;
            offsetY = mouseY - worldY * scale;

            updateZoomDisplay();
            draw();
        }, { passive: false });

        // ã‚¿ãƒƒãƒæ“ä½œå¯¾å¿œï¼ˆãƒ¢ãƒã‚¤ãƒ«ç”¨ï¼‰
        let lastTouchDistance = 0;
        let lastTouchCenter = { x: 0, y: 0 };

        canvas.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) {
                isDragging = true;
                lastMouseX = e.touches[0].clientX;
                lastMouseY = e.touches[0].clientY;
            } else if (e.touches.length === 2) {
                isDragging = false;
                const dx = e.touches[1].clientX - e.touches[0].clientX;
                const dy = e.touches[1].clientY - e.touches[0].clientY;
                lastTouchDistance = Math.sqrt(dx * dx + dy * dy);
                lastTouchCenter = {
                    x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
                    y: (e.touches[0].clientY + e.touches[1].clientY) / 2
                };
            }
            e.preventDefault();
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            if (e.touches.length === 1 && isDragging) {
                const dx = e.touches[0].clientX - lastMouseX;
                const dy = e.touches[0].clientY - lastMouseY;
                offsetX += dx;
                offsetY += dy;
                lastMouseX = e.touches[0].clientX;
                lastMouseY = e.touches[0].clientY;
                draw();
            } else if (e.touches.length === 2) {
                const dx = e.touches[1].clientX - e.touches[0].clientX;
                const dy = e.touches[1].clientY - e.touches[0].clientY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const center = {
                    x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
                    y: (e.touches[0].clientY + e.touches[1].clientY) / 2
                };

                if (lastTouchDistance > 0) {
                    const scaleChange = distance / lastTouchDistance;
                    const newScale = scale * scaleChange;
                    
                    if (newScale >= 0.1 && newScale <= 500) {
                        const rect = canvas.getBoundingClientRect();
                        const touchX = center.x - rect.left;
                        const touchY = center.y - rect.top;

                        const worldX = (touchX - offsetX) / scale;
                        const worldY = (touchY - offsetY) / scale;

                        scale = newScale;

                        offsetX = touchX - worldX * scale;
                        offsetY = touchY - worldY * scale;

                        // ãƒ‘ãƒ³æ“ä½œã‚‚åŒæ™‚ã«
                        offsetX += center.x - lastTouchCenter.x;
                        offsetY += center.y - lastTouchCenter.y;

                        updateZoomDisplay();
                        draw();
                    }
                }

                lastTouchDistance = distance;
                lastTouchCenter = center;
            }
            e.preventDefault();
        }, { passive: false });

        canvas.addEventListener('touchend', (e) => {
            if (e.touches.length < 2) {
                lastTouchDistance = 0;
            }
            if (e.touches.length === 0) {
                isDragging = false;
            }
            e.preventDefault();
        }, { passive: false });

        // åˆæœŸåŒ–
        resizeCanvas();
    </script>
</body>
</html>
